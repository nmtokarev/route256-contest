# Route-256 contest 01.07.2022-03.07.2022
- [Route-256 contest 01.07.2022-03.07.2022](#route-256-contest-01072022-03072022)
  - [Task B. Парное программирование (10 баллов)](#task-b-парное-программирование-10-баллов)
  - [Task С. Оповещения (10 баллов)](#task-с-оповещения-10-баллов)
  - [Task D. Подсказчик паролей (10 баллов)](#task-d-подсказчик-паролей-10-баллов)
  - [Task E. Отчет (15 баллов)](#task-e-отчет-15-баллов)
  - [Task F. Отрезки времени (20 баллов)](#task-f-отрезки-времени-20-баллов)
  - [Task G. Возможные друзья (20 баллов)](#task-g-возможные-друзья-20-баллов)
## Task B. Парное программирование (10 баллов)

В компании работает n разработчиков, где n — четное число. Сумасшедший менеджер решил разбить всех разработчиков на команды по два человека.

Для этого он составил список всех разработчиков и назначил каждому из них номер по списку (от $1$ до $n$) и значение $a_i$ — уровень мастерства $i$-го в списке разработчика.

Очередную команду он составляет следующим образом:

- первый разработчик в команде тот, кто идет первым в списке;
- ему в пару подбирается такой, что разница их уровней минимальна (то есть минимально значение $|a_i−a_j|$, где $|x|$ — это модуль числа $x$); если таких кандидатов несколько, то выбирается из них тот, кто находится раньше в списке;
- эти два разработчика образуют команду и удаляются из списка.
  
Например, если массив a равен $[2,1,3,1,1,4]$, то формирование команд будет происходить следующим образом:

- назначим разработчикам номера $[1,2,3,4,5,6]$ в соответствии с их положением в списке, первый среди них имеет номер 1, его уровень мастерства $a_1$=2, подходящими (с минимальной абсолютной разностью) являются разработчики с номерами 2,3,4,5, первый среди них 2, таким образом первая команда — это разработчики с номерами 1 и 2;
- оставшиеся разработчики теперь имеют номера $[3,4,5,6]$, первый среди них 3, его уровень $a_3$=3, разработчик с минимальной абсолютной разностью только один (номер 6), таким образом команда — разработчики с номерами 3 и 6;
- оставшиеся разработчики имеют номера $[4,5]$, первый среди них 4, его уровень $a_4$=1, остался только разработчик с номером 5, таким образом третья команда — разработчики с номерами 4 и 5.
  
Ваша задача — помочь сумасшедшему менеджеру промоделировать процесс разбиения на команды. Обратите внимание, что команды должны быть выведены в порядке, описанном выше в условии.

**Входные данные**

Первая строка содержит одно целое число t ($1 \leq t \leq 50$) — количество наборов входных данных.

Первая строка каждого набора содержит одно целое число n ($2 \leq n \leq 50$; $n$ четное) — количество разработчиков.

Вторая строка содержит n целых чисел $a_1$,$a_2$,…,$a_n$ ($1 \leq a_i \leq 100$), где $a_i$ — уровень мастерства $i$-го разработчика.

**Выходные данные**

Для каждого набора входных данных выведите $n/2$ строк, $i$-я строка должна содержать пару чисел — номер первого и второго разработчика в $i$-й команде в порядке, описанном в условии.

Выводите пустую строку между выводами для наборов входных данных.

**Пример входных данных**

    3
    6
    2 1 3 1 1 4
    2
    5 5
    8
    1 4 2 5 4 2 6 3

**Пример выходных данных**

    1 2
    3 6
    4 5

    1 2

    1 3
    2 5
    4 7
    6 8

## Task С. Оповещения (10 баллов)

Вам поручено разработать систему оповещений для мессенджера. Мессенджером пользуются n пользователей; им присвоены идентификационные номера от $1$ до $n$. Оповещения, которые должны приходить пользователям, могут быть двух типов:

- глобальное оповещение, приходящее всем пользователям (например, при обновлении версии мессенджера);
- персональное оповещение, приходящее одному пользователю (например, когда ему приходит сообщение в диалоге).
  
Оповещения получают номера, начиная с $1$, в порядке их отправления. То есть первое отправленное оповещение (неважно, глобальное или персональное) получает номер $1$, второе — номер $2$, и так далее.

Когда пользователь загружает мессенджер, на экране загрузки сразу же должно отображаться последнее из оповещений, пришедших ему. Вам необходимо реализовать программу, которая будет выводить эту информацию.

Формально, ваша программа должна обрабатывать последовательность запросов двух типов:

- $1$ $id$ ($0 \leq id \leq n$) — отправить пользователю $id$ оповещение, или же, если $id=0$, отправить оповещение всем пользователям;
- $2$ $id$ ($1 \leq id \leq n$) — для пользователя $id$ вывести номер последнего оповещения, которое ему приходило, или $0$, если ему еще не приходило оповещений.
  
Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.

**Входные данные**

В первой строке заданы два целых числа $n$ и $q$ ($1 \leq n$, $q \leq 3⋅105$) — количество пользователей и количество запросов, соответственно.

Далее следуют $q$ строк, описывающих запросы в хронологическом порядке (то есть в порядке их совершения). Каждый запрос задан в отдельной строке и состоит из двух чисел $t$ и $id$ ($1 \leq t \leq 2$; $0 \leq id \leq n$, если $t=1$, или $1 \leq id \leq n$, если $t=2$). Первое число — тип запроса (тип 1 — отправить оповещение, тип 2 — вывести последнее оповещение для пользователя); второе число — идентификатор пользователя (при $t=1$ может быть $id=0$, это означает, что оповещение является глобальным).

Во входных данных обязательно будет хотя бы один запрос типа $2$.

**Выходные данные**

На каждый запрос второго типа выведите ответ в отдельной строке — номер последнего оповещения, которое пришло пользователю на момент обработки этого запроса, или $0$, если ему еще не приходило оповещений.

**Пример входных данных**

    6 10
    1 4
    2 5
    1 6
    2 4
    1 0
    1 2
    2 2
    2 1
    1 0
    2 3

**Пример выходных данных**

    0
    1
    4
    3
    5

**Примечание**

Рассмотрим запросы из примера из условия.

первый запрос — индивидуальное оповещение для пользователя 4, оно получает номер 1;\
второй запрос — узнать номер последнего оповещения для пользователя 5. Ему не приходило оповещений, поэтому ответ на запрос — 0;\
третий запрос — индивидуальное оповещение для пользователя 6, оно получает номер 2;\
четвертый запрос — узнать номер последнего оповещения для пользователя 4. Ему приходило только одно оповещение, номер которого — 1, поэтому ответом на этот запрос является 1;\
пятый запрос — глобальное оповещение для всех пользователей, оно получает номер 3;\
шестой запрос — индивидуальное оповещение для пользователя 2, оно получает номер 4;\
седьмой запрос — узнать номер последнего оповещения для пользователя 2. Ему приходили оповещения 3 и 4, поэтому ответ — 4;\
восьмой запрос — узнать номер последнего оповещения для пользователя 1. Ему приходило только оповещение 3, поэтому ответ — 3;\
девятый запрос — глобальное оповещение для всех пользователей, оно получает номер 5;\
десятый запрос — узнать номер последнего оповещения для пользователя 3. Ему приходили оповещения 3 и 5, поэтому ответ — 5.

## Task D. Подсказчик паролей (10 баллов)

Вам поручили реализовать модуль, который помогает пользователю придумать надежный пароль.

Пароль называется надежным, если он состоит только из букв латинского алфавита, а также цифр, и содержит в себе:

- хотя бы одну прописную букву (букву в верхнем регистре);
- хотя бы одну строчную букву (букву в нижнем регистре);
- хотя бы одну гласную букву;
- хотя бы одну согласную букву;
- хотя бы одну цифру.
  
Гласными буквами в этой задаче будем считать следующие буквы латинского алфавита: e, u, i, o, a, y (а также их аналоги в верхнем регистре). Остальные же буквы считаются согласными. Заметьте, что буква y является только гласной.

Вам задан список пользователей, отправивших свои пароли на сервер. Для каждого пароля вам необходимо дополнить его минимальным количеством символов справа таким образом, чтобы он считался надежным. Если существует несколько способов дополнить пароль минимальным количеством символов, вам разрешается вывести любой из них.

Обратите внимание, что если пароль уже является надежным, то его не нужно дополнять.

**Входные данные**

В первой строке входных данных задано одно целое число $t$ ($1 \leq t \leq 500$) — количество пользователей, отправивших пароли на сервер.

Далее следуют описания паролей пользователей. Единственная строка описания пароля содержит строку $s$ длины от $1$ до $20$. Строка содержит только цифры и/или строчные/прописные буквы латинского алфавита.

**Выходные данные**

Для каждого пользователя выведите в новой строке предлагаемый ему пароль. Заметьте, что выведенный пароль должен быть дополнен справа минимальным количеством символов таким образом, чтобы он считался надежным. Если существует несколько способов дополнить пароль минимальным количеством символов, вам разрешается вывести любой из них. Пароли выводите в порядке их поступления во входных данных.

**Пример входных данных**

    5
    passw0rd
    2
    aq
    Ay0
    3xE

**Пример выходных данных**

    passw0rdD
    2lO
    aqF2
    Ay0c
    3xE

## Task E. Отчет (15 баллов)

Директор IT-корпорации оценивает эффективность работы сотрудников по различным показателям и критериям. Один из этих критериев сформулирован следующим образом: приступив к некоторому заданию, сотрудник должен завершить его, не переключаясь на другие задания.

Чтобы проверить сотрудников на соответствие этому критерию, директор потребовал от каждого сотрудника отчет о том, какие задания он выполнял в последние $n$ дней. Отчет — это последовательность из $n$ целых чисел $a_1$,$a_2$,…,$a_n$, где $a_i$ — идентификатор задания, которое сотрудник выполнял в $i$-й день.

Вам необходимо написать программу, проверяющую, соответствует ли сотрудник критерию по его отчету. Сотрудник соответствует этому критерию, если не существует такого задания $x$, которое выполнялось с перерывом (т. е. в некоторый день $i$ сотрудник выполнял задание $x$, в дни с $i+1$ по $j−1$ он занимался другими заданиями, а в день $j$ сотрудник продолжил выполнение задания $x$, при этом $j>i+1$). Иными словами, каждое задание, которое выполнял сотрудник, должно занимать один непрерывный отрезок дней.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.

**Входные данные**

В первой строке задано одно целое число $t$ ($1\leq t \leq 10$) — количество наборов входных данных.

Каждый набор входных данных состоит из двух строк. В первой строке задано одно целое число $n$ ($3\leq n \leq 50000$). Во второй строке заданы $n$ целых чисел $a_1$,$a_2$,…,$a_n$ ($1 \leq a_i \leq n$) — отчет сотрудника.

**Выходные данные**

Для каждого набора входных данных выведите ответ на отдельной строке. Если отчет соответствует критерию, выведите YES, иначе выведите NO.

**Пример входных данных**

    5
    5
    1 2 3 4 5
    4
    1 2 3 1
    8
    2 3 4 8 5 5 5 5
    5
    1 1 3 2 2
    5
    1 1 2 3 2

**Пример выходных данных**

    YES
    NO
    YES
    YES
    NO

## Task F. Отрезки времени (20 баллов)

Вам задан набор отрезков времени. Каждый отрезок задан в формате HH:MM:SS-HH:MM:SS, то есть сначала заданы часы, минуты и секунды левой границы отрезка, а затем часы, минуты и секунды правой границы.

Вам необходимо выполнить валидацию заданного набора отрезков времени. Иными словами, вам нужно проверить следующие условия:

часы, минуты и секунды заданы корректно (то есть часы находятся в промежутке от 0 до 23, а минуты и секунды — в промежутке от 0 до 59);
левая граница отрезка находится не позже его правой границы (но границы могут быть равны);
никакая пара отрезков не пересекается (даже в граничных моментах времени).
Вам необходимо вывести YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае.

Вам необходимо ответить на $t$ независимых наборов тестовых данных.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.

**Входные данные**

Первая строка входных данных содержит одно целое число $t$ ($1 \leq t \leq 10$) — количество наборов тестовых данных. Затем следуют $t$ наборов.

Первая строка набора содержит одно целое число $n$ ($1 \leq n \leq 2⋅104$) — количество отрезков времени. В следующих n строках следуют описания отрезков.

Описание отрезка времени задано в формате HH:MM:SS-HH:MM:SS, где HH, MM и SS — последовательности из двух цифр. Заметьте, что никаких пробелов в описании формата нет. Также ни в одном описании нет пробелов в начале и конце строки.

**Выходные данные**

Для каждого набора тестовых данных выведите ответ — YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае. Ответы выводите в порядке следования наборов во входных данных.

**Пример входных данных**

    6
    1
    02:46:00-03:14:59
    2
    23:59:59-23:59:59
    00:00:00-23:59:58
    2
    23:59:58-23:59:59
    00:00:00-23:59:58
    2
    23:59:59-23:59:58
    00:00:00-23:59:57
    6
    17:53:39-20:20:02
    10:39:17-11:00:52
    08:42:47-09:02:14
    09:44:26-10:21:41
    00:46:17-02:07:19
    22:42:50-23:17:46
    1
    24:00:00-23:59:59

**Пример выходных данных**

    YES
    YES
    NO
    NO
    YES
    NO

## Task G. Возможные друзья (20 баллов)

Во многих социальных сетях у пользователей есть возможность указать других пользователей как своих друзей. Помимо этого, часто существует система рекомендации друзей, которая показывает пользователям людей, с которыми они знакомы косвенно (через кого-то из своих друзей), и предлагает добавить этих людей в список друзей. Вам предстоит разработать систему рекомендации друзей.

В интересующей нас социальной сети n пользователей, каждому из которых присвоен уникальный $id$ от $1$ до $n$. У каждого пользователя этой сети не более $5$ друзей. Очевидно, ни один пользователь не является другом самому себе, и если пользователь $x$ в списке друзей у пользователя $y$, то и пользователь $y$ входит в список друзей пользователя $x$.

Опишем, как должен формироваться список возможных друзей для каждого пользователя. Для пользователя $x$ в список должны входить такие пользователи $y$, что:

- $y$ не является другом $x$ и не совпадает с $x$;
- у пользователя $y$ и у пользователя $x$ есть хотя бы один общий друг;
- не существует такого пользователя $y$′, который удовлетворяет первым двум ограничениям, и у которого строго больше общих друзей с $x$, чем у $y$ с $x$.
  
Иными словами, в список возможных друзей пользователя $x$ входят все такие пользователи, не являющиеся его друзьями, для которых количество общих друзей с $x$ максимально. Обратите внимание, что список возможных друзей может быть пустым.

Вы должны написать программу, которая по заданной структуре социальной сети формирует списки возможных друзей для всех пользователей сети.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.

**Входные данные**

В первой строке заданы два целых числа $n$ и $m$ ($2 \leq n \leq 50000$; $0 \leq m \leq min(n(n−1)^2,5n^2))$ — количество пользователей и количество пар друзей, соответственно.

Далее следуют m строк, в каждой из которых заданы два целых числа $x_i$ и $y_i$ ($1 \leq x_i$,$y_i \leq n$; $x_i \neq y_i$) — очередная пара друзей в социальной сети. Каждая пара друзей задается не более одного раза; у каждого пользователя не более $5$ друзей.

**Выходные данные**

Для каждого пользователя от $1$ до $n$ выведите в отдельной строке список его возможных друзей в следующем формате:

- если список возможных друзей пуст, выведите одно целое число $0$;
- иначе выведите $id$ возможных друзей пользователя в возрастающем порядке.

**Пример входных данных**

    8 6
    4 3
    3 1
    1 2
    2 4
    2 5
    6 8

**Пример выходных данных**

    4
    3
    2
    1
    1 4
    0
    0
    0

**Пример входных данных**

    8 10
    1 2
    1 3
    1 4
    4 3
    3 2
    2 4
    1 8
    5 6
    7 6
    5 7

**Пример выходных данных**

    0
    8
    8
    8
    0
    0
    0
    2 3 4

**Примечание**

Рассмотрим первый пример из условия.

Для начала сформируем списки друзей всех пользователей:

друзья пользователя 1: [2,3].\
друзья пользователя 2: [1,4,5].\
друзья пользователя 3: [1,4].\
друзья пользователя 4: [2,3].\
друзья пользователя 5: [2].\
друзья пользователя 6: [8].\
друзья пользователя 7: [] (список друзей пуст).\
друзья пользователя 8: [6].\
Рассмотрим, как формируются списки возможных друзей для некоторых пользователей.

У пользователя 1 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 4 (общие друзья 2 и 3) и пользователь 5 (общий друг 2). С пользователем 4 общих друзей больше, поэтому в список возможных друзей попадает только он.

У пользователя 5 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 1 (общий друг 2) и пользователь 4 (общий друг 2). Количество общих друзей одинаковое, поэтому оба этих пользователя попадают в список возможных друзей.

У пользователя 7 вообще нет друзей, поэтому ни один пользователь не удовлетворяет требованиям списка возможных друзей.